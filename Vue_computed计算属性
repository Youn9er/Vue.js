computed计算属性：
	计算属性缓存 vs 方法：

		可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
		相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
		我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。

	计算属性 vs 侦听属性：

		Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。

	计算属性的 setter：

		计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：
			// ...
			computed: {
			  fullName: {
			    // getter
			    get: function () {
			      return this.firstName + ' ' + this.lastName
			    },
			    // setter
			    set: function (newValue) {
			      var names = newValue.split(' ')
			      this.firstName = names[0]
			      this.lastName = names[names.length - 1]
			    }
			  }
			}
			// ...
			现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。

	侦听器：
	
		虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的